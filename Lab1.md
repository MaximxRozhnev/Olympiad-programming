# 1.	Длинна палочек
Есть n палочек с некоторой длиной. Ваша задача - модифицировать палочки так, чтобы каждая палочка имела одинаковую длину.
Вы можете удлинить или укоротить каждую палку. Стоимость обеих операций x, где x - это разница между новой и исходной длиной.
Какова минимальная общая стоимость?
Входные данные
Первая строка ввода содержит целое число n: количество палочек. 
Тогда есть n целых чисел: p1, p2,…, pn: длина палочек.
Выходные данные
Выведите одно целое число: минимальная общая стоимость.
``` ПРИМЕР
Входные данные
5
2 3 1 5 2
Выходные данные
5
```
```Код
import math

minimal = 0
average = 0
count = int(input())
numbers = list(map(int, input().split(" ")))
numbers = sorted(numbers)

average = numbers[math.floor(count/2)-1]
for i in numbers:
    minimal += abs(i-average)
print(minimal)
```

# 2.	 Нахождение делителей. 
Для n целых чисел, ваша задача состоит в том, чтобы вывести для каждого целого числа количество его делителей.
Например, если x = 18, правильный ответ - 6, потому что его делители 1,2,3,6,9,18.
Входные данные
Первая строка ввода имеет целое число n: количество целых чисел.
После этого идет n строк, каждая из которых содержит целое число x.
Выходные данные
Для каждого целого числа вывести число его делителей.
``` ПРИМЕР
Входные данные
3
16
17
18
Выходные данные
5
2
6
```
```Код
countOfNumber = int(input())
numbers = []
for i in range(countOfNumber):
    numbers.append(int(input()))

for i in numbers:
    countDelimiter = 0
    for n in range(1, int(i / 2) + 1):
        if i % n == 0:
            countDelimiter += 1
    print(countDelimiter + 1)
```

# 3.	Круг студентов
n студентов выстроились в кругу в некотором порядке. Индекс i-го студента равен pi. Гарантируется, что все индексы студентов — различные целые числа от 1 до n (то есть они образуют перестановку).
Студенты хотят станцевать хоровод. Прямой хоровод можно станцевать тогда, когда студент 2 идет сразу же после студента 1 в порядке по часовой стрелке (между ними не должно стоять студентов), студент 3 идет сразу же после студента 2 в порядке по часовой стрелке, и так далее, и студент n идет сразу же за студентом n−1 в порядке по часовой стрелке. Обратный хоровод — почти то же самое. Единственное отличие в том, что студент i должен идти сразу же после студента i−1 в порядке против часовой стрелки (это условие должно выполняться для всех i от 2 до n). 
Например, если индексы студентов в порядке по часовой стрелке равны [2,3,4,5,1], то они могут станцевать прямой хоровод. Если индексы студентов равны [3,2,1,4] в порядке по часовой стрелке, тогда они смогут станцевать обратный хоровод.
Ваша задача — определить, возможно ли станцевать хоровод. Заметьте, что студенты не могут менять своих позиций перед началом танца; они не могут меняться местами или покидать круг, а также никакой другой студент не может встать в круг. 
Вам необходимо ответить на q независимых запросов.
Входные данные
Первая строк входных данных содержит одно целое число q (1≤q≤200) — количество запросов. Затем следуют q запросов.
Первая строка запроса содержит одно целое число n (1≤n≤200) — количество студентов.
Вторая строка запроса содержит перестановку индексов p1,p2,…,pn (1≤pi≤n), где pi равно индексу i-го студента (в порядке по часовой стрелке). Гарантируется, что все pi — различные целые числа от 1 до n (то есть они образуют перестановку).
Выходные данные
Для каждого запроса, выведите ответ на него. Если можно станцевать хоровод с выбранным порядком студентов, выведите «YES». Иначе выведите «NO».
``` ПРИМЕР
Входные данные
5
4
1 2 3 4
3
1 3 2
5
1 2 3 5 4
1
1
5
3 2 1 5 4
Выходные данные
YES
YES
NO
YES
YES
```
``` Код
circles = int(input())
answers = []
for circle in range(circles):
    numbersCount = int(input())
    numbers = list(map(int, input().split(" ")))
    Flag = True
    for num in range(len(numbers)-1):
        if(numbers[num] == 1 and numbers[num+1] == numbersCount):
            continue
        elif(numbers[num] == numbersCount and numbers[num+1] == 1):
            continue
        elif(abs(numbers[num] - numbers[num+1]) == 1):
            continue
        else:
            Flag = False
    answers.append("YES" if Flag else "NO")
for i in answers:
    print(i)
```

# 4.	Одинаковые прямоугольники
Вам задано 4n палочек, длина i-й палочки равна ai.
Вам необходимо составить n прямоугольников, каждый из которых будет состоять ровно из 4 палочек из заданного набора. Прямоугольник имеет четыре стороны, противоположные стороны должны иметь одинаковые длины и все углы в нем должны быть прямые. Заметьте, что каждая палочка может быть использована только в одном прямоугольнике. Каждая палочка должна быть использована как сторона, вы не можете ломать палочки или использовать не ее полную длину.
Вы хотите, чтобы все прямоугольники имели одинаковую площадь. Площадь прямоугольника со сторонами a и b равна a⋅b.
Ваша задача — сказать, возможно ли составить ровно n прямоугольников одинаковой площади или нет.
Вам необходимо ответить на q независимых запросов.
Входные данные
Первая строка входных данных содержит одно целое число q
(1≤q≤500) — количество запросов. Затем следуют q запросов.
Первая строка каждого запроса содержит одно целое число n
(1≤n≤100) — количество прямоугольников.
Вторая строка запроса содержит 4n целых чисел a1,a2,…,a4n (1≤ai≤104), где ai равно длине i-й палочки.
Выходные данные
Для каждого запроса выведите ответ на него. Если невозможно составить ровно n прямоугольников одинаковой площади при помощи заданных палочек, выведите «NO». Иначе выведите «YES».
``` ПРИМЕР
Входные данные
5
1
1 1 10 10
2
10 5 2 10 1 1 2 5
2
10 5 1 10 5 1 1 1
2
1 1 1 1 1 1 1 1
1
10000 10000 10000 10000
Выходные данные
YES
YES
NO
YES
YES
```
``` Код
import math

circles = int(input())
answers = []

for circle in range(circles):
    numbersCount = int(input())
    count = []
    numbers = list(map(int, input().split(" ")))
    numbers = sorted(numbers)
    
    for i in range(math.floor(len(numbers)/2)):
        count.append(numbers[i] * numbers[-1 - i])

    count = list(set(count))
    answers.append("YES" if len(count) == 1 else "NO")
    
for i in answers:
    print(i)   
```

# 5.	БОКСЁРЫ
Есть n боксёров, вес i-го равен ai. Каждый из них перед соревнованием может изменить свой вес не более чем на 1 (вес не может стать равным нулю, то есть должен остаться положительным). Вес — это всегда целое число.
Необходимо выбрать наибольшую по количеству человек такую команду боксёров, что все веса боксёров в ней — различны.
Напишите программу, которая для заданных текущих значений ai найдет максимальное возможное количество боксёров в команде.
Возможно, что после какого-то изменения вес какого-то боксера станет 150001 (но не больше).
Входные данные
В первой строке задано единственное целое число n
(1≤n≤150000) — количество боксёров. В следующей строке через единичный пробел заданы n целых чисел a1,a2,…,an, где ai (1≤ai≤150000) — вес i -го боксёра.
Выходные данные
Выведите единственное целое число — максимальное возможное количество человек в команде.
``` ПРИМЕРЫ
Входные данные
4
3 2 4 1
Выходные данные
4

Входные данные
6
1 1 1 4 4 4
Выходные данные
5
```
В первом примере боксёры не должны менять свои веса — можно просто из всех них составить команду.
Во втором примере можно одного боксёра веса 1 увеличить на единицу (получить вес 2), одного боксёра веса 4 уменьшить на единицу, а другого — увеличить на единицу (получив боксёров с весами 3 и 5 соответственно). Таким образом, можно получить команду, состоящую из боксёров с весами 5,4,3,2,1.
``` Код
count = int(input())
numbers = list(map(int, input().split(" ")))
have = []

for number in numbers:
    if not number in have:
        have.append(number)
    elif number - 1 != 0 and not number - 1 in have:
        have.append(number - 1)
    elif not number + 1 in have:
        have.append(number + 1)

print(len(have))
```
